using BRSERP.Validadores;
using System;
using System.Globalization;

namespace BRSERP
{
    public static class StringExtensions
    {
        public static bool Vacio(this string cadena)
        {
            return string.IsNullOrWhiteSpace(cadena);
        }

        public static string Formatear(this string cadena, params object[] parametros)
        {
            return string.Format(cadena, parametros);
        }

        public static int AsInt(this string cadena)
        {
            return Convert.ToInt32(cadena);
        }

        public static int? AsNInt(this string cadena)
        {
            int? valor = null;
            if (!cadena.Vacio())
                valor = cadena.AsInt();
            return valor;
        }

        public static short AsShort(this string cadena)
        {
            return Convert.ToInt16(cadena);
        }

        public static short? AsNShort(this string cadena)
        {
            short? valor = null;
            if (!cadena.Vacio())
                valor = cadena.AsShort();
            return valor;
        }

        public static decimal AsDecimal(this string cadena)
        {
            return Convert.ToDecimal(cadena);
        }

        /// <summary>
        /// Devuelve una cadena con las comillas simples al principio y al final
        /// </summary>
        /// <param name="cadena"></param>
        /// <returns>La cadena entre comillas simples y las comillas simples dobladas</returns>
        public static string Quoted(this string cadena)
        {
            // Realizamos el Replace para poder insertar en la BD alguna cadena con el caracter "'" (Ej.: PRUEBA'S)
            // La forma de que la SQL lo acepte es doblando la comilla "''";
            cadena = cadena.Replace("'", "''");
            return string.Format("\'{0}\'", cadena);
        }

        /// <summary>
        /// Devuelve el número de veces que se repite una subcadena en una cadena
        /// </summary>
        /// <param name="cadena"></param>
        /// <param name="cSubCadena">Texto que queremos buscar en la cadena</param>
        /// <returns>Número de ocurrencias de la subcadena</returns>
        public static int Ocurrencias(this string cadena, string cSubCadena)
        {
            int nOcurrencias = cadena.Split(new String[] { cSubCadena }, StringSplitOptions.None).Length - 1;
            return nOcurrencias;
        }

        /// <summary>
        /// Devuelve true si el objeto es un número, false en caso contrario
        /// </summary>
        /// <param name="cadena">Variable objeto a verificar</param>
        /// <returns>Si el objeto es numérico</returns>
        public static bool IsNumeric(this string cadena)
        {
            bool lEsNumero;
            lEsNumero = Double.TryParse(cadena.Replace(".", ""), NumberStyles.Any, NumberFormatInfo.InvariantInfo, out double nNumero);
            return lEsNumero;
        }

        /// <summary>
        /// Devuelte true si el objeto es una fecha, false en caso contrario
        /// </summary>
        /// <param name="cadena">Variable objeto a verificar</param>
        /// <returns>Si el objeto es una fecha</returns>
        public static bool IsDate(this string cadena)
        {
            bool lEsFecha;
            lEsFecha = DateTime.TryParse(cadena, out DateTime dFecha);
            if (!lEsFecha)
            {
                lEsFecha = BRSLibValidadores.EsFechaCorrecta(cadena, out string cFechaFormateada);
            }
            return lEsFecha;
        }

        /// <summary>
        /// Devuelte true si el objeto es una hora, false en caso contrario
        /// </summary>
        /// <param name="cadena">Variable objeto a verificar</param>
        /// <returns>Si el objeto es una hora</returns>
        public static bool IsHour(this string cadena)
        {
            bool lEsHora = DateTime.TryParse(cadena, out DateTime dHora);
            if (!lEsHora) lEsHora = BRSLibValidadores.EsHoraCorrecta(cadena);
            return lEsHora;
        }

        /// <summary>
        /// Función que formatea un número añadiendo puntos de millar y comas decimales (si fuera necesario)
        /// </summary>
        /// <param name="cadena"></param>
        /// <param name="nDecimales">El número de decimales admitidos</param>
        /// <param name="soloPositivos">Si sólamente admite números positivos</param>
        /// <returns></returns>
        public static string FormatearNumero(this string cadena, int nDecimales = 0, bool soloPositivos = true)
        {
            string cFormato = "N" + nDecimales;

            if (!cadena.Vacio() && (cadena[0] == '.' || cadena[0] == ','))
            { // Si la cadena empieza por '.' ó ',' añadimos un 0 a la izquierda (Ej: .5 = 0.5)
                cadena = cadena.Insert(0, "0");
            }

            // Comprobamos los casos en los que la cadena ya está formateada (Ej.: 1.234 ó 1.234,5) y causa un funcionamiento incorrecto
            if (nDecimales == 0)
            { // Si no tenemos decimales eliminamos los puntos
                cadena = cadena.Replace(".", "");
            }
            else
            { // Si tenemos decimales
                int nContadorPuntos = cadena.Length - cadena.Replace(".", "").Length; // Contamos el número de '.' en la cadena
                int nContadorComas = cadena.Length - cadena.Replace(",", "").Length; // Contamos el número de ',' en la cadena

                for (int i = 0; i < nContadorPuntos; i++)
                {
                    if (i == nContadorPuntos - 1 && nContadorComas == 0)
                    { // Si es el último punto '.' y no tenemos coma ',', el usuario lo ha puesto para escribir decimales y lo cambiamos por ','
                        cadena = cadena.Replace(".", ",");
                    }
                    else
                    { // Si no, eliminamos los puntos
                        cadena = cadena.Replace(".", "");
                    }
                }
            }

            // Procedemos a formatear la cadena
            if (!cadena.IsNumeric())
            { // Si no es un número borramos la cadena
                cadena = "";
            }
            else if (Convert.ToDecimal(cadena) < 0 && soloPositivos)
            { // Si es un número negativo y sólo admitimos positivos, borramos la cadena
                cadena = "";
            }

            if (!cadena.Vacio())
            {
                cadena = Convert.ToDecimal(cadena.Replace(".", ",")).ToString(cFormato);
            }

            return cadena;
        }

        /// <summary>
        /// Función que elimina los puntos de millar y reemplaza las comas decimales por puntos
        /// </summary>
        /// <param name="cadena"></param>
        /// <returns></returns>
        public static string RestaurarNumero(this string cadena)
        {
            return cadena.Replace(".", "").Replace(",", ".");
        }

        /// <summary>
        /// Función que comprueba si un número como cadena se encuentra dentro de los rangos permitidos
        /// </summary>
        /// <param name="cadena"></param>
        /// <param name="tipoRango">0 para short, 1 para int, 2 para decimal</param>
        /// <param name="formatoDecimal">Si el tipo rango es 2, se debe especificar el número de dígitos en total como máximo más el número máximo de dígitos en la parte decimal. Ej: 5,2 valida 100,00</param>
        /// <returns></returns>
        public static bool CadenaDentroRango(this string cadena, TipoRango tipoRango, string formatoDecimal = "0,0")
        {
            bool lDentroRango = false;
            switch (tipoRango)
            {
                case TipoRango.SHORT:
                    lDentroRango = Int16.TryParse(cadena, out short shortParsed);
                    break;
                case TipoRango.INT:
                    lDentroRango = Int32.TryParse(cadena, out int intParsed);
                    break;
                case TipoRango.DECIMAL:
                    if (decimal.TryParse(cadena, out decimal decimalParsed))
                    {
                        int totalDigitos = Convert.ToInt32(formatoDecimal.Split(',')[0]);
                        int totalDecimales = Convert.ToInt32(formatoDecimal.Split(',')[1]);
                        lDentroRango = cadena.Replace(",", "").Length <= totalDigitos && cadena.Split(',')[1].Length <= totalDecimales;
                    }
                    else
                    {
                        lDentroRango = false;
                    }
                    break;
            }

            return lDentroRango;
        }

        public static string[] Split(this string cadena, string separador)
        {
            return cadena.Split(new string[] { separador }, StringSplitOptions.None);
        }

        /// <summary>Tipos de rangos usados para la función CadenaDentroRango</summary>
        public enum TipoRango { SHORT, INT, DECIMAL };


        /// <summary>
        /// Función que comprueba si un número decimal como cadena se encuentra dentro de los rangos permitidos según la longitud dada
        /// </summary>
        /// <param name="nMaxDigitos">Longitud de almacenamiento del valor Decimal</param>
        /// <returns></returns>
        public static bool CheckDecimal(this string cadena, int nMaxDigitos)
        {
            bool lResult = true;
            string climiteNumerico = "1";

            if (!string.IsNullOrWhiteSpace(cadena))
            {
                string[] acNumeroReal = cadena.Split(new Char[] { ',' });

                string cParteEntera = RestaurarNumero(acNumeroReal[0]);
                string cParteDecimal = "";
                if (acNumeroReal.Length > 1) cParteDecimal = acNumeroReal[1];

                for (int indice = 0; indice < (nMaxDigitos - cParteDecimal.Length); indice++)
                {
                    climiteNumerico += "0";
                }

                double nlimiteNumerico = Convert.ToDouble(climiteNumerico);
                double numero = Convert.ToDouble(cParteEntera);
                if (numero >= nlimiteNumerico)
                {
                    lResult = false;
                }
            }

            return lResult;
        }

        /// <summary>
        /// Función que comprueba si un número no decimal como cadena se encuentra por debajo del máximo valor permitido
        /// </summary>
        /// <param name="nlimiteNumerico">Valor límite</param>
        /// <returns></returns>
        public static bool CheckNumerico(this string cadena, long nlimiteNumerico = 1)
        {
            bool lResult = true;

            if (!string.IsNullOrWhiteSpace(cadena))
            {
                double numero = Convert.ToDouble(cadena);
                if (numero >= nlimiteNumerico)
                {
                    lResult = false;
                }
            }

            return lResult;
        }
    }
}
