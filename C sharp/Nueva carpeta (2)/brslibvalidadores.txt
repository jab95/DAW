using System;
using System.Globalization;
using System.Text.RegularExpressions;
using Telerik.WinControls.UI;

namespace BRSLibReyes.Validadores
{
    public class BRSLibValidadores
    {
        /// <summary>
        /// Función que comprueba si un valor se encuentra entre dos rangos
        /// </summary>
        /// <param name="minimo">El valor mínimo</param>
        /// <param name="maximo">El valor máximo</param>
        /// <param name="inclusive">Si deben contarse los extremos</param>
        /// <param name="valores">Lista de parametros a comprobar</param>
        /// <returns>Verdadero o falso si todos los valores se encuentran entre los rangos indicados</returns>
        public static bool ValorEnteroEntreRangos(int minimo, int maximo, bool inclusive, params object[] valores)
        {
            foreach (object objeto in valores)
            {
                int valor = 0;

                if (objeto is int xInt)
                {
                    valor = Convert.ToInt32(xInt);
                }
                else if (objeto is string xString)
                {
                    valor = Convert.ToInt32(Math.Ceiling(Convert.ToDecimal(xString)));
                }
                else if (objeto is RadTextBox xRadTextBox)
                {
                    valor = Convert.ToInt32(Math.Ceiling(Convert.ToDecimal(xRadTextBox)));
                }
                else if (objeto is int[] xIntArray)
                {
                    foreach (int xInt2 in xIntArray)
                    {
                        valor = xInt2;
                        if (inclusive)
                        {
                            if (valor < minimo || valor > maximo)
                                return false;
                        }
                        else
                        {
                            if (valor <= minimo || valor >= maximo)
                                return false;
                        }
                    }
                }
                else if (objeto is string[] xStringArray)
                {
                    foreach (string xString2 in xStringArray)
                    {
                        valor = Convert.ToInt32(xString2);
                        if (inclusive)
                        {
                            if (valor < minimo || valor > maximo)
                                return false;
                        }
                        else
                        {
                            if (valor <= minimo || valor >= maximo)
                                return false;
                        }
                    }
                }
                else
                {
                    throw new ArgumentException();
                }

                if (inclusive)
                {
                    if (valor < minimo || valor > maximo)
                        return false;
                }
                else
                {
                    if (valor <= minimo || valor >= maximo)
                        return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Función que comprueba si cadena escrita como hora en formato HH:mm ó HHmm es correcta
        /// </summary>
        /// <param name="cHorasMinutos">La cadena con la hora a comprobar</param>
        /// <returns>Verdadero o falso</returns>
        public static bool EsHoraCorrecta(string cHorasMinutos)
        {
            bool error = true;

            string[] horasMinutos = new string[2];
            if (cHorasMinutos.Contains(":"))
            { // Si contiene : dividimos la cadena a traves de los :
                horasMinutos = cHorasMinutos.Split(':');
            }
            else if (cHorasMinutos.Length == 4)
            { // Si no contiene : y la longitud es de 4
                horasMinutos[0] = cHorasMinutos.Substring(0, 2);
                horasMinutos[1] = cHorasMinutos.Substring(2, 2);
            }
            else if (cHorasMinutos.Length == 3)
            { // Si no contiene : y la longitud es de 3
                horasMinutos[0] = cHorasMinutos.Substring(0, 1);
                horasMinutos[1] = cHorasMinutos.Substring(1, 2);
            }
            int nhoras = int.Parse(horasMinutos[0]);
            int nminutos = int.Parse(horasMinutos[1]);
            int nsegundos = -1;

            if (cHorasMinutos.Split(':').Length > 2)
            {
                nsegundos = int.Parse(horasMinutos[2]);
            }

            if ((nhoras >= 0 && nhoras <= 23) && (nminutos >= 0 && nminutos <= 59))
            {
                // Si las horas están entre 0 y 23 y los minutos entre 0 y 59
                if (nsegundos != -1 && (nsegundos >= 0 && nsegundos <= 59))
                {
                    // Si contiene segundos y estan entre 0 y 59
                    error = false;
                }
                else
                {
                    error = false;
                }
            }
            return error;
        }

        /// <summary>
        /// Función que comprueba si una cadena escrita en un textbox es una fecha correcta
        /// </summary>
        /// <param name="textBoxFecha">La cadena con la fecha a comprobar</param>
        /// <param name="cFechaFormateada">La fecha formateada</param>
        /// <returns>Verdadero o falso</returns>
        public static bool EsFechaCorrecta(RadTextBox textBoxFecha, out string cFechaFormateada)
        {
            return EsFechaCorrecta(textBoxFecha.Text, out cFechaFormateada);
        }

        /// <summary>
        /// Función que comprueba si una cadena escrita como fecha es correcta
        /// </summary>
        /// <param name="cFecha">La cadena con la fecha a comprobar</param>
        /// <param name="cFechaFormateada">La fecha formateada</param>
        /// <returns>Verdadero o falso</returns>
        public static bool EsFechaCorrecta(string cFecha, out string cFechaFormateada)
        {
            bool lCorrecto;
            cFechaFormateada = "";

            // Vamos a comprobar si la fecha viene con el símbolo de separación
            if ((!cFecha.Contains("/")) && (cFecha.Trim().Length >= 6))
            {
                if (cFecha.Trim().Length == 6) // Ej: 010101
                {
                    cFecha = cFecha.Substring(0, 2) + "/" + cFecha.Substring(2, 2) + "/" + cFecha.Substring(4, 2);
                }
                else if (cFecha.Trim().Length == 8) // Ej: 01011001. Si la parte del año la tomamos con longitud 2, al hacer el TryParse nos interpreta 01 cómo 2001. Tenemos que coger el año completo
                {
                    cFecha = cFecha.Substring(0, 2) + "/" + cFecha.Substring(2, 2) + "/" + cFecha.Substring(4, 4);
                }
            }

            if (DateTime.TryParseExact(cFecha, "dd/MM/yy", null, DateTimeStyles.NoCurrentDateDefault, out DateTime parsedDate))
            {
                lCorrecto = true;
            }
            else if (DateTime.TryParseExact(cFecha, "dd/MM/yyyy", null, DateTimeStyles.None, out DateTime parsedDate2))
            {
                lCorrecto = true;
            }
            else
            {
                lCorrecto = false;
            }

            if (lCorrecto)
                cFechaFormateada = cFecha;

            return lCorrecto;
        }

        #region Comprobar NIF-CIF

        /// <summary>
        /// Función que comprueba si un NIF/CIF insertado es válido
        /// </summary>
        /// <param name="cNIFCIF">El NIF/CIF que queremos comprobar</param>
        /// <remarks>Adaptación del código https://gist.github.com/afgomez/5691823 </remarks>
        /// <returns></returns>
        public static bool ComprobarNIFCIF(string cNIFCIF)
        {
            try
            {
                cNIFCIF = cNIFCIF.ToUpper().Replace(" ", "");

                bool lValido = false;
                string tipoID = TipoID(cNIFCIF);
                switch (tipoID)
                {
                    case "dni": lValido = ValidarDNI(cNIFCIF); break;
                    case "cif": lValido = ValidarCIF(cNIFCIF); break;
                    case "nie": lValido = ValidarNIE(cNIFCIF); break;
                    default: lValido = false; break;
                }

                return lValido;
            }
            catch (Exception)
            {
                return false;
            }
        }

        /// <summary>
        /// Función que devuelve el tipo de identificador fiscal insertado
        /// </summary>
        /// <param name="cNIFCIF">El identificador</param>
        /// <returns>Una cadena que contiene dni, cif, nie o invalido</returns>
        private static string TipoID(string cNIFCIF)
        {
            const string DNI_REGEX = "(\\d{8}[A-Z])";
            const string CIF_REGEX = "([ABCDEFGHJKLMNPQRSUVW]\\d{7}[0-9A-J])";
            const string NIE_REGEX = "([XYZ]\\d{7}[A-Z])";

            if (Regex.IsMatch(cNIFCIF, DNI_REGEX))
                return "dni";
            if (Regex.IsMatch(cNIFCIF, CIF_REGEX))
                return "cif";
            if (Regex.IsMatch(cNIFCIF, NIE_REGEX))
                return "nie";
            return "invalido";
        }

        /// <summary>
        /// Funcíón que valida un DNI
        /// </summary>
        /// <param name="dni">Un DNI</param>
        /// <returns>Si es correcto o no</returns>
        private static bool ValidarDNI(string dni)
        {
            const string letrasDNI = "TRWAGMYFPDXBNJZSQVHLCKE";
            char letra = letrasDNI[int.Parse(dni.Substring(0, 8)) % 23];
            return letra == dni[8];
        }

        /// <summary>
        /// Función que valida un NIE
        /// </summary>
        /// <param name="nie">Un NIE</param>
        /// <returns>Si es correcto o no</returns>
        private static bool ValidarNIE(string nie)
        {
            char prefijo = nie[0];
            switch (prefijo)
            {
                case 'X': prefijo = '0'; break;
                case 'Y': prefijo = '1'; break;
                case 'Z': prefijo = '2'; break;
            }
            return ValidarDNI(prefijo + nie.Substring(1));
        }

        /// <summary>
        /// Función que valida un CIF
        /// </summary>
        /// <param name="cif">Un CIF</param>
        /// <returns>Si es correcto o no</returns>
        private static bool ValidarCIF(string cif)
        {
            int sumaPares = 0;
            int sumaImpares = 0;
            int n;
            string letra = cif.Substring(0, 1);
            string control = cif.Substring(8);

            string parteNumerica = cif.Substring(1, 7);

            for (int i = 0; i < parteNumerica.Length; i++)
            {
                n = int.Parse(Convert.ToString(parteNumerica[i]));
                if (i % 2 == 0)
                { // Si es una posición impar
                    // Multiplicamos por 2 el valor del número
                    n *= 2;
                    // Si la multiplicación es superior a 10 ajustamos el número
                    sumaImpares += n < 10 ? n : n - 9;
                }
                else
                { // Si es una posición par
                    sumaPares += n;
                }
            }

            if (sumaImpares + sumaPares > 10)
                n = Convert.ToInt32((sumaPares + sumaImpares).ToString().Substring(1));
            else
                n = sumaPares + sumaImpares;

            int digitoControl = 10 - n;
            if (digitoControl == 10) digitoControl = 0;
            string letraControl = "JABCDEFGHI".Substring(digitoControl, 1);

            if ("ABEH".Contains(letra))
            { // El control tiene que se un número
                return control == Convert.ToString(digitoControl);
            }
            else if ("KPQS".Contains(letra))
            { // El control tiene que ser una letra
                return control == letraControl;
            }
            else
            { // El control puede ser una letra o número
                return control == Convert.ToString(digitoControl) || control == letraControl;
            }
        }

        #endregion

        #region Comprobar Datos Bancarios

        /// <summary>
        /// Función que comprueba el digito de control de una cuenta bancaria
        /// </summary>
        /// <param name="_cEntidad">El código de entidad</param>
        /// <param name="_cSucursal">El código de sucursal</param>
        /// <param name="_cDC">El dígito de control insertado</param>
        /// <param name="_cCuenta">El código de cuenta</param>
        /// <param name="_nDCCalculado">El dígito de control calculado en caso de que sea erróneo</param>
        /// <param name="_cNacionalidad">La nacionalidad para comprobar el dígito de control</param>
        /// <returns>Si es válido o no</returns>
        public static bool Comprobar_CCC_DigitoControl(string _cEntidad, string _cSucursal, string _cDC, string _cCuenta, out int _nDCCalculado, string _cNacionalidad = "ES")
        {
            bool lValido = false;
            _nDCCalculado = 0;
            if (_cNacionalidad == "ES")
            { // Si la nacionalidad es española
                int nDCInsertado = _cDC.AsInt();

                // Para calcular el primer dígito de control primero cogemos el número de la entidad
                // y multiplicamos el primer dígito por 4, el segundo por 8, el tercero por 5 y el cuarto por 10
                // y sumamos todos esos dígitos
                int sumaA = _cEntidad.Substring(0, 1).AsInt() * 4;
                sumaA += _cEntidad.Substring(1, 1).AsInt() * 8;
                sumaA += _cEntidad.Substring(2, 1).AsInt() * 5;
                sumaA += _cEntidad.Substring(3, 1).AsInt() * 10;

                // A continuación cogemos el número de la sucursal 
                // y multiplicamos el primer dígito por 9, el segundo por 7, el tercero por 3 y el cuarto por 6
                // y sumamos todos los números
                int sumaB = _cSucursal.Substring(0, 1).AsInt() * 9;
                sumaB += _cSucursal.Substring(1, 1).AsInt() * 7;
                sumaB += _cSucursal.Substring(2, 1).AsInt() * 3;
                sumaB += _cSucursal.Substring(3, 1).AsInt() * 6;

                // Sumamos A+B y restamos a 11 el resto de dividir A+B entre once
                int codigo1 = 11 - ((sumaA + sumaB) % 11);

                // El número obtenido es el primer dígito de control a excepción de si es 10, que el dígito sería 1, o si es 11, el dígito es 0
                if (codigo1 == 10) codigo1 = 1;
                else if (codigo1 == 11) codigo1 = 0;

                // Para calcular el segundo dígito de control multiplicamos el primer dígito de la cuenta por 1,
                // el segundo por 2, el tercero por 4, el cuarto por 8, el quinto por 6, el sexto por 10, el séptimo por 9,
                // el octavo por 7, el noveno por 3 y el décimo por 6
                int sumaC = _cCuenta.Substring(0, 1).AsInt();
                sumaC += _cCuenta.Substring(1, 1).AsInt() * 2;
                sumaC += _cCuenta.Substring(2, 1).AsInt() * 4;
                sumaC += _cCuenta.Substring(3, 1).AsInt() * 8;
                sumaC += _cCuenta.Substring(4, 1).AsInt() * 5;
                sumaC += _cCuenta.Substring(5, 1).AsInt() * 10;
                sumaC += _cCuenta.Substring(6, 1).AsInt() * 9;
                sumaC += _cCuenta.Substring(7, 1).AsInt() * 7;
                sumaC += _cCuenta.Substring(8, 1).AsInt() * 3;
                sumaC += _cCuenta.Substring(9, 1).AsInt() * 6;

                // Restamos a 11 el resto de dividir la suma entre 11
                int codigo2 = 11 - (sumaC % 11);

                // El número obtenido es el primer dígito de control a excepción de si es 10, que el dígito sería 1, o si es 11, el dígito es 0
                if (codigo2 == 10) codigo2 = 1;
                else if (codigo2 == 11) codigo2 = 0;

                // Juntamos los dos dígitos de control
                _nDCCalculado = (codigo1 * 10) + codigo2;

                if (_nDCCalculado == nDCInsertado)
                { // Si el dígito calculado es igual al dígito insertado, lo damos por válido
                    lValido = true;
                }
            }
            return lValido;
        }

        /// <summary>
        /// Función que comprueba el IBAN de una cuenta bancaria
        /// </summary>
        /// <param name="_cEntidad">El código de entidad</param>
        /// <param name="_cSucursal">El código de sucursal</param>
        /// <param name="_cDC">El dígito de control</param>
        /// <param name="_cCuenta">El código de cuenta</param>
        /// <param name="_cIBAN">El IBAN insertado</param>
        /// <param name="_cIBANCalculado">El IBAN calculado en caso de que sea erróneo</param>
        /// <param name="_cNacionalidad">La nacionalidad para comprobar el dígito de control</param>
        /// <returns>Si es válido o no</returns>
        public static bool Comprobar_CCC_IBAN(string _cEntidad, string _cSucursal, string _cDC, string _cCuenta, string _cIBAN, out string _cIBANCalculado, string _cNacionalidad = "ES")
        {
            bool lValido = false;
            _cIBANCalculado = null;

            if (_cNacionalidad == "ES")
            { // Si la nacionalidad es la española
                // Cogemos la cuenta bancaria completa Entidad + Sucursal + DC + Cuenta
                // Añadimos al final ES00, reemplazando E por 14 y S por 28
                string CCC = _cEntidad.PadLeft(4, '0') + _cSucursal.PadLeft(4, '0') + _cDC.PadLeft(2, '0') + _cCuenta.PadLeft(10, '0') + "142800";
                decimal valor = Convert.ToDecimal(CCC);
                int nresto = Convert.ToInt32(valor % 97);
                nresto = 98 - nresto;
                _cIBANCalculado = "ES";
                if (nresto < 10)
                {
                    _cIBANCalculado += "0" + nresto.AsString();
                }
                else
                {
                    _cIBANCalculado += nresto.AsString();
                }

                if (_cIBAN == _cIBANCalculado)
                { // Si el IBAN calculado es igual al IBAN insertado, lo damos por válido
                    lValido = true;
                }
            }
            return lValido;
        }

        #endregion
    }
}
