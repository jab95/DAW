using Npgsql;
using System;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;

namespace BRSLibReyes
{
    /// <summary>
    /// Clase usada para generar archivos log
    /// </summary>
    public class BRSLog
    {
        StreamWriter writer = null;
        string cNombreFichero;
        string cExtensionFichero;
        string cTituloLog;
        bool lDebug;
        public bool lLogVacio;

        string cRutaDebug;
        string cFichero;

        string ultimaFechaEscrita = "";

        public enum LINEAVACIA { NO, ANTES, DESPUES, AMBOS };
        public enum PALABRA_CLAVE { ABRIR, CONSTRUCTOR, ACTIVAR, CERRAR, ENTRAR, EVENTO, SALIR, VALIDAR, CONSULTA, LISTADO, INSERTAR, ACTUALIZAR, BORRAR, ENCONTRAR, ERROR_EXCEPCION, COMIENZA_PROCESO, FIN_PROCESO, LOG, CLICK, MOSTRAR, PERSONALIZADO };

        /// <summary>
        /// Constructor de la clase
        /// </summary>
        /// <param name="nombreFichero">El nombre del fichero sin extensión</param>
        /// <param name="tituloLog">El texto que aparecerá como cabecera del log (ya incluye la fecha)</param>
        /// <param name="extensionFichero">La extensión del fichero de log</param>
        /// <param name="debug">Si es un log para depuración</param>
        public BRSLog(string nombreFichero, string tituloLog, string extensionFichero = "txt", bool debug = false)
        {
            this.cNombreFichero = nombreFichero;
            this.cExtensionFichero = extensionFichero;
            this.cTituloLog = tituloLog;
            this.lDebug = debug;
            this.lLogVacio = true;

            cRutaDebug = BRSLib.cRutaLogs + "debug\\";
            cFichero = cNombreFichero + "." + cExtensionFichero;

            // Crea el archivo de log, si ya existía uno con el mismo nombre lo borramos
            if (lDebug)
            {
                BorrarLog();
                BorrarLogsAntiguos();

                if (!Directory.Exists(cRutaDebug))
                    Directory.CreateDirectory(cRutaDebug);
                writer = new StreamWriter(cRutaDebug + cFichero);
            }
            else
            {
                BorrarLog();
                var fileInfo = new FileInfo(BRSLib.cRutaLogs + cFichero);
                Directory.CreateDirectory(fileInfo.DirectoryName);
                writer = new StreamWriter(BRSLib.cRutaLogs + cFichero);
            }

            // Pinta la cabecera del log
            if (!tituloLog.Vacio())
            {
                writer.WriteLine(DateTime.Now.ToString("G") + " - " + tituloLog);
                writer.WriteLine("");
            }

            writer.Close();
        }

        /// <summary>
        /// Método para pintar una linea en el log
        /// </summary>
        /// <param name="_mensaje">Mensaje que queremos incluir</param>
        /// <param name="_lineaVacia">¿Insertar línea vacía?</param>
        public void WriteLine(string _mensaje, LINEAVACIA _lineaVacia = LINEAVACIA.NO)
        {
            writer = new StreamWriter(BRSLib.cRutaLogs + cNombreFichero + "." + cExtensionFichero, true);

            if (_lineaVacia == LINEAVACIA.AMBOS || _lineaVacia == LINEAVACIA.ANTES)
                writer.WriteLine();

            writer.WriteLine(_mensaje);

            if (_lineaVacia == LINEAVACIA.AMBOS || _lineaVacia == LINEAVACIA.DESPUES)
                writer.WriteLine();

            writer.Close();
            lLogVacio = false;
        }

        /// <summary>
        /// Método para pintar una linea en el log de depuración
        /// </summary>
        /// <param name="_mensaje">Mensaje que queremos incluir</param>
        /// <param name="_clase">Nombre de la clase desde donde se llama</param>
        /// <param name="_funcion">Nombre de la función desde donde se llama (sin "()")</param>
        /// <param name="_palabra">Palabra clave asignada</param>
        /// <param name="_palabraPersonalizada">Palabra clave personalizada</param>
        /// <param name="_lineaVacia">¿Insertar línea vacía?</param>
        public void WriteLineDebug(string _mensaje, string _clase, string _funcion, PALABRA_CLAVE _palabra = PALABRA_CLAVE.LOG, string _palabraPersonalizada = "", LINEAVACIA _lineaVacia = LINEAVACIA.NO, Exception _ex = null, IDbCommand oComando = null)
        {
            try
            {
                if (lDebug)
                {
                    if (writer != null)
                    {
                        string _clave, _linea;

                        // Creamos el directorio donde almacenar los logs de depuración
                        if (!Directory.Exists(cRutaDebug))
                            Directory.CreateDirectory(cRutaDebug);
                        writer = new StreamWriter(cRutaDebug + cFichero, true);

                        // Añadimos una línea vacía antes si se requiere
                        if (_lineaVacia == LINEAVACIA.AMBOS || _lineaVacia == LINEAVACIA.ANTES)
                            writer.WriteLine();

                        // Añadimos la clave en función de la palabra seleccionada
                        switch (_palabra)
                        {
                            case PALABRA_CLAVE.ABRIR: _clave = "ABRIR"; break;
                            case PALABRA_CLAVE.ACTIVAR: _clave = "ACTIVAR"; break;
                            case PALABRA_CLAVE.ACTUALIZAR: _clave = "ACTUALIZAR"; break;
                            case PALABRA_CLAVE.BORRAR: _clave = "BORRAR"; break;
                            case PALABRA_CLAVE.CERRAR: _clave = "CERRAR"; break;
                            case PALABRA_CLAVE.COMIENZA_PROCESO: _clave = "COMIENZA PROCESO"; break;
                            case PALABRA_CLAVE.CONSTRUCTOR: _clave = "CONSTRUCTOR"; break;
                            case PALABRA_CLAVE.CONSULTA: _clave = "CONSULTA"; break;
                            case PALABRA_CLAVE.ENCONTRAR: _clave = "ENCONTRAR"; break;
                            case PALABRA_CLAVE.ENTRAR: _clave = "ENTRAR"; break;
                            case PALABRA_CLAVE.ERROR_EXCEPCION: _clave = "ERROR EXCEPCION"; break;
                            case PALABRA_CLAVE.FIN_PROCESO: _clave = "FIN PROCESO"; break;
                            case PALABRA_CLAVE.INSERTAR: _clave = "INSERTAR"; break;
                            case PALABRA_CLAVE.LISTADO: _clave = "LISTADO"; break;
                            case PALABRA_CLAVE.SALIR: _clave = "SALIR"; break;
                            case PALABRA_CLAVE.VALIDAR: _clave = "VALIDAR"; break;
                            case PALABRA_CLAVE.CLICK: _clave = "CLICK"; break;
                            case PALABRA_CLAVE.MOSTRAR: _clave = "MOSTRAR"; break;
                            case PALABRA_CLAVE.EVENTO: _clave = "EVENTO"; break;
                            case PALABRA_CLAVE.PERSONALIZADO: _clave = _palabraPersonalizada.ToUpper(); break;
                            default: _clave = "LOG"; break;
                        }

                        // Añadimos la fecha y hora
                        string fecha = "[" + DateTime.Now.ToString("G") + "] ";
                        if (fecha == ultimaFechaEscrita)
                            fecha = new string(' ', fecha.Length);
                        else
                            ultimaFechaEscrita = fecha;

                        _linea = fecha;

                        switch (_palabra)
                        {
                            case PALABRA_CLAVE.ABRIR:
                                // Si la clave es abrir y trae mensaje es el modo
                                if (string.IsNullOrWhiteSpace(_mensaje))
                                    _linea += (_clave + " " + _clase);
                                else
                                    _linea += (_clave + " MODO " + _mensaje + " " + _clase);
                                break;

                            case PALABRA_CLAVE.ENTRAR:
                            case PALABRA_CLAVE.SALIR:
                            case PALABRA_CLAVE.VALIDAR:
                                // Si es entrar, salir o validar, añadimos el campo desde donde se llamó
                                _linea += (_clave + " " + _mensaje);
                                break;

                            default:
                                _linea += _clave;
                                break;
                        }

                        // Añadimos la clase y la función desde donde se llamó
                        if (_palabra == PALABRA_CLAVE.PERSONALIZADO && string.IsNullOrWhiteSpace(_palabraPersonalizada))
                            _linea += "    " + new string(' ', _clase.Length) + " " + new string(' ', _funcion.Length) + "  ";
                        else
                            _linea += " -- " + _clase + ":" + _funcion + "()";

                        if (!string.IsNullOrWhiteSpace(_mensaje))
                        {
                            switch (_palabra)
                            {
                                case PALABRA_CLAVE.ABRIR:
                                case PALABRA_CLAVE.ENTRAR:
                                case PALABRA_CLAVE.SALIR:
                                case PALABRA_CLAVE.VALIDAR:
                                    // Si es abrir, entrar, salir o validar no hacemos nada
                                    break;

                                default:
                                    // En caso contrario añadimos el mensaje
                                    _linea += " - ";
                                    if (oComando != null && oComando.Connection != null && !string.IsNullOrWhiteSpace(oComando.Connection.Database))
                                    { // Si trae un objeto comando anexamos al mensaje la base de datos con la que estamos trabajando
                                        _linea += "[" + oComando.Connection.Database + "] ";
                                        if (oComando.Transaction != null)
                                        { // Si el comando tiene una transacción indicamos que se encuentra en una
                                            _linea += "(TRANSACTION) ";
                                        }
                                    }
                                    _linea += _mensaje;
                                    break;
                            }
                        }

                        // Pintamos la línea
                        writer.WriteLine(_linea);

                        if (_palabra == PALABRA_CLAVE.ERROR_EXCEPCION && _ex != null)
                        { // Si la palabra clave es ERROR_EXCEPCION y trae una excepción
                          // Añadimos como siguientes líneas el mensaje del error y su traceado
                            writer.WriteLine(_ex.Message);
                            writer.WriteLine(_ex.StackTrace);
                        }

                        // Añadimos una línea vacía después si se requiere
                        if (_lineaVacia == LINEAVACIA.AMBOS || _lineaVacia == LINEAVACIA.DESPUES)
                            writer.WriteLine();

                        writer.Close();
                    }

                    lLogVacio = false;
                }
            }
            catch (Exception)
            {
            }
        }

        /// <summary>
        /// Función para cerrar el flujo del log
        /// </summary>
        public void Close()
        {
            writer.Close();
        }

        /// <summary>
        /// Función para abrir el archivo log con el visor de logs
        /// </summary>
        public void AbrirLog()
        {
            BRSVisorLog visor = new BRSVisorLog(cTituloLog, @BRSLib.cRutaLogs + cNombreFichero + "." + cExtensionFichero);
            visor.ShowDialog();
        }

        /// <summary>
        /// Función para abrir el archivo log con la aplicación predeterminada de Windows
        /// </summary>
        public void AbrirLogTxt()
        {
            string archivo;
            if (lDebug)
                archivo = cRutaDebug + cNombreFichero + "." + cExtensionFichero;
            else
                archivo = @BRSLib.cRutaLogs + cNombreFichero + "." + cExtensionFichero;
            Process.Start(archivo);
        }

        /// <summary>
        /// Función que pregunta si queremos abrir el log
        /// </summary>
        /// <param name="mensaje">Mensaje para la ventana</param>
        /// <param name="titulo">Título de la ventana</param>
        /// <param name="icono">Icono que mostrará la ventana</param>
        /// <returns>Yes para 'Sí', No para 'No', Cancel para 'Ver informe'</returns>
        public DialogResult PreguntarAbrirLogTresOpciones(string mensaje, string titulo = " ", BRSLib.Icono icono = BRSLib.Icono.Information)
        {
            MessageBoxManager.Yes = "Sí";
            MessageBoxManager.No = "No";
            MessageBoxManager.Cancel = "Ver informe";

            MessageBoxManager.Register();
            DialogResult result = BRSLib.MostrarMensaje(mensaje, titulo, BRSLib.Boton.YesNoCancel, icono);
            MessageBoxManager.Unregister();

            return result;
        }

        /// <summary>
        /// Función para borrar el archivo log
        /// </summary>
        public void BorrarLog()
        {
            try
            {
                if (lDebug)
                {
                    if (File.Exists(cRutaDebug + cFichero))
                        File.Delete(cRutaDebug + cFichero);
                }
                else
                {
                    if (File.Exists(BRSLib.cRutaLogs + cFichero))
                        File.Delete(BRSLib.cRutaLogs + cFichero);
                }
            }
            catch (Exception ex)
            {
                BRSLib.MostrarMensaje(ex.Message + "\n\rBRSLog : BorrarLog()", " ", BRSLib.Boton.OK, BRSLib.Icono.Error);
            }
        }

        /// <summary>
        /// Función que borra los logs antiguos para la aplicación actual
        /// manteniendo sólo 10 logs por programa
        /// </summary>
        public void BorrarLogsAntiguos()
        {
            if (Directory.Exists(cRutaDebug))
            {
                string cNombreAplicacion = cFichero.Split('_')[0];
                // Recupera del directorio de logs los logs que pertenecen a la aplicación actual
                string[] acFicheros = Directory.GetFiles(cRutaDebug, cNombreAplicacion + "*", SearchOption.TopDirectoryOnly);
                // Los ordena por orden descendente
                Array.Sort<string>(acFicheros, new Comparison<string>((i1, i2) => i2.CompareTo(i1)));
                for (int i = 0; i < acFicheros.Length; i++)
                {
                    // Borramos todos los logs que no se encuentren entre los 9 primeros
                    if (i > 8)
                    {
                        try
                        {
                            File.Delete(acFicheros[i]);
                        }
                        catch (Exception)
                        {
                        }
                    }
                }
            }
        }

        public string ObtenerRutaFichero()
        {
            return BRSLib.cRutaLogs + cNombreFichero + "." + cExtensionFichero;
        }

        public static PALABRA_CLAVE PalabraClaveSQL(string cSQL)
        {
            PALABRA_CLAVE palabraClave;
            switch (cSQL.Substring(0, 6).ToUpper())
            {
                case "SELECT": palabraClave = PALABRA_CLAVE.CONSULTA; break;
                case "INSERT": palabraClave = PALABRA_CLAVE.INSERTAR; break;
                case "UPDATE": palabraClave = PALABRA_CLAVE.ACTUALIZAR; break;
                case "DELETE": palabraClave = PALABRA_CLAVE.BORRAR; break;
                default: palabraClave = PALABRA_CLAVE.LOG; break;
            }
            return palabraClave;
        }

        public static void GuardarLogExcepcion(Exception ex)
        {
            if (Directory.Exists(BRSLib.cRutaLogs))
                Directory.CreateDirectory(BRSLib.cRutaLogs);

            string temp = "";

            if (File.Exists(BRSLib.cRutaLogs + "excepcion.log"))
            {
                using (StreamReader reader = new StreamReader(BRSLib.cRutaLogs + "excepcion.log"))
                {
                    temp = reader.ReadToEnd();
                }

                try
                {
                    string[] tempArray = temp.Split(new string[] { "\r\n\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    string[] tempArray2;
                    int maxMensajes = 20;

                    if (tempArray.Length >= maxMensajes)
                    {
                        tempArray2 = new string[maxMensajes];
                        for (int i = 0; i < tempArray2.Length - 1; i++)
                        {
                            tempArray2[i] = tempArray[i];
                        }
                    }
                    else
                    {
                        tempArray2 = tempArray;
                    }
                    temp = string.Join("\r\n\r\n", tempArray2);
                }
                catch (Exception)
                {
                }
            }

            using (StreamWriter writer = new StreamWriter(BRSLib.cRutaLogs + "excepcion.log"))
            {
                writer.WriteLine(DateTime.Now.ToString("dd/MM/yyyy HH:mm:ss.fff - " + ex.GetType().Name));
                writer.WriteLine(ex.Message);
                if (ex is NpgsqlException pex)
                    writer.WriteLine(pex.Detail);
                writer.WriteLine(ex.StackTrace);
                writer.WriteLine("");
                writer.Write(temp);
            }
        }

        #region Funciones resumidas para escribir logs

        public static void WriteLogDebug_Click(string _clase, string _funcion)
        {
            BRSLib.WriteLogDebug("", _clase, _funcion, BRSLog.PALABRA_CLAVE.CLICK, "", BRSLog.LINEAVACIA.ANTES);
        }

        public static void WriteLogDebug_Constructor(string _clase)
        {
            BRSLib.WriteLogDebug("", _clase, _clase, BRSLog.PALABRA_CLAVE.CONSTRUCTOR, "", BRSLog.LINEAVACIA.ANTES);
        }

        public static void WriteLogDebug_Load(string _clase, short? Modo = null)
        {
            string cModo = Modo == null ? "" : Convert.ToString(Modo);
            BRSLib.WriteLogDebug(cModo, _clase, _clase + "_Load", BRSLog.PALABRA_CLAVE.ABRIR, "", BRSLog.LINEAVACIA.ANTES);
        }

        public static void WriteLogDebug_Activated(string _clase)
        {
            BRSLib.WriteLogDebug("", _clase, _clase + "_Activated", BRSLog.PALABRA_CLAVE.ACTIVAR, "", BRSLog.LINEAVACIA.ANTES);
        }

        public static void WriteLogDebug_Close(string _clase)
        {
            BRSLib.WriteLogDebug("", _clase, _clase + "_FormClosed", BRSLog.PALABRA_CLAVE.CERRAR, "", BRSLog.LINEAVACIA.DESPUES);
        }

        public static void WriteLogDebug_ProcesoInicio(string _clase, string _funcion)
        {
            BRSLib.WriteLogDebug("", _clase, _funcion, PALABRA_CLAVE.COMIENZA_PROCESO, "", LINEAVACIA.ANTES);
        }

        public static void WriteLogDebug_ProcesoFin(string _clase, string _funcion)
        {
            BRSLib.WriteLogDebug("", _clase, _funcion, PALABRA_CLAVE.FIN_PROCESO, "", LINEAVACIA.DESPUES);
        }

        #endregion
    }
}
